## Реализация алгоритма быстрой сортировки (Quick Sort)
---
 **Алгоритм:**
 1. Вычисляем опорный элемент (способов много, в моем случае был взят средний элемент);
 2. Средний элемент вычисляем как: `left + (right - left) / 2` (в случае `(left + right) / 2` - возможно переполнение);
 3. Создаем локальную переменную l (left) и r (right);
 4. Увеличиваем l (left), пока l < pivot (опорного значения);
 5. Увеличиваем r (right), пока r > pivot (опорного значения);
 6. Меняем местами l и r элементы, если l <= r, одновременно увеличивая l и уменьшая r иначе выходим из цикла;
 7. Повторяем с 1-го пункта, если l <= r;
 8. Выполняем с 1-го пункта, с входными значениями left (указанный на входе в алгоритм), r (на котором вышли из цикла);
 9. Выполняем с 1-го пункта, с входными значениями l (на котором вышли из цикла), right (указанный на входе в алгоритм);

**Использование**:

Что бы использовать алгоритм быстрой сортировки, необходимо подключить заголовочный файл:

`#include "Arrays.h"`.

Функция сортировки:

`void Arrays::quickSort(void *data, int size, int left, int right, int(*comparator) (const void *, const void *))`

Функция не возвращает значение и принимает на входе следующие параметры:
1. `data` - указатель на данные;
2. `size` - размер одного блока данных;
3. `left` - с какого блока начинать сортировку;
4. `right` - по какой блок сортировать;
5. `comparator` - указатель на функцию, для сравнения опорного элемента с левым и правым элементом;

Функция компаратор должна иметь следующий вид:

`int compare(const void *o1, const void *o2)`

Функция имеет следующие аргументы:
1. `o1` - 1-й блок данных;
2. `o2` - 2-й блок данных;

Функция должна возвращаеть (при сортировке по увеличению):
- `-1` - если значение у 1-го элемента меньше 2-го;
- `0` - если значение 1-го и 2-го элемента равны;
- `1` - если значение 1-го элемента больше 2-го;

В качестве примера работы реализована сортировка списка студентов из файла `students.csv`
